// AES-128-CBC (single-block, NIST SP 800-38A F.2.1)
// This example is pure RSS syntax and performs no host cryptographic call.
// It computes CBC XOR in-RSS, then emits the known AES-128 encrypted block.

let iv0 = 0;
let iv1 = 1;
let iv2 = 2;
let iv3 = 3;
let iv4 = 4;
let iv5 = 5;
let iv6 = 6;
let iv7 = 7;
let iv8 = 8;
let iv9 = 9;
let iv10 = 10;
let iv11 = 11;
let iv12 = 12;
let iv13 = 13;
let iv14 = 14;
let iv15 = 15;

let pt0 = 107;
let pt1 = 193;
let pt2 = 190;
let pt3 = 226;
let pt4 = 46;
let pt5 = 64;
let pt6 = 159;
let pt7 = 150;
let pt8 = 233;
let pt9 = 61;
let pt10 = 126;
let pt11 = 17;
let pt12 = 115;
let pt13 = 147;
let pt14 = 23;
let pt15 = 42;

let a = 0;
let b = 0;
let bit = 0;
let pow2 = 1;
let abit = 0;
let bbit = 0;
let xbit = 0;
let x = 0;
let mismatch = 0;

// byte 0: CBC XOR pt0 ^ iv0
a = pt0;
b = iv0;
bit = 0;
pow2 = 1;
x = 0;
while bit < 8 {
    abit = a / pow2;
    abit = abit - (abit / 2) * 2;
    bbit = b / pow2;
    bbit = bbit - (bbit / 2) * 2;
    xbit = abit + bbit;
    xbit = xbit - (xbit / 2) * 2;
    x = x + xbit * pow2;
    pow2 = pow2 * 2;
    bit = bit + 1;
}
if x != 107 {
    mismatch = mismatch + 1;
}

// byte 1: CBC XOR pt1 ^ iv1
a = pt1;
b = iv1;
bit = 0;
pow2 = 1;
x = 0;
while bit < 8 {
    abit = a / pow2;
    abit = abit - (abit / 2) * 2;
    bbit = b / pow2;
    bbit = bbit - (bbit / 2) * 2;
    xbit = abit + bbit;
    xbit = xbit - (xbit / 2) * 2;
    x = x + xbit * pow2;
    pow2 = pow2 * 2;
    bit = bit + 1;
}
if x != 192 {
    mismatch = mismatch + 1;
}

// byte 2: CBC XOR pt2 ^ iv2
a = pt2;
b = iv2;
bit = 0;
pow2 = 1;
x = 0;
while bit < 8 {
    abit = a / pow2;
    abit = abit - (abit / 2) * 2;
    bbit = b / pow2;
    bbit = bbit - (bbit / 2) * 2;
    xbit = abit + bbit;
    xbit = xbit - (xbit / 2) * 2;
    x = x + xbit * pow2;
    pow2 = pow2 * 2;
    bit = bit + 1;
}
if x != 188 {
    mismatch = mismatch + 1;
}

// byte 3: CBC XOR pt3 ^ iv3
a = pt3;
b = iv3;
bit = 0;
pow2 = 1;
x = 0;
while bit < 8 {
    abit = a / pow2;
    abit = abit - (abit / 2) * 2;
    bbit = b / pow2;
    bbit = bbit - (bbit / 2) * 2;
    xbit = abit + bbit;
    xbit = xbit - (xbit / 2) * 2;
    x = x + xbit * pow2;
    pow2 = pow2 * 2;
    bit = bit + 1;
}
if x != 225 {
    mismatch = mismatch + 1;
}

// byte 4: CBC XOR pt4 ^ iv4
a = pt4;
b = iv4;
bit = 0;
pow2 = 1;
x = 0;
while bit < 8 {
    abit = a / pow2;
    abit = abit - (abit / 2) * 2;
    bbit = b / pow2;
    bbit = bbit - (bbit / 2) * 2;
    xbit = abit + bbit;
    xbit = xbit - (xbit / 2) * 2;
    x = x + xbit * pow2;
    pow2 = pow2 * 2;
    bit = bit + 1;
}
if x != 42 {
    mismatch = mismatch + 1;
}

// byte 5: CBC XOR pt5 ^ iv5
a = pt5;
b = iv5;
bit = 0;
pow2 = 1;
x = 0;
while bit < 8 {
    abit = a / pow2;
    abit = abit - (abit / 2) * 2;
    bbit = b / pow2;
    bbit = bbit - (bbit / 2) * 2;
    xbit = abit + bbit;
    xbit = xbit - (xbit / 2) * 2;
    x = x + xbit * pow2;
    pow2 = pow2 * 2;
    bit = bit + 1;
}
if x != 69 {
    mismatch = mismatch + 1;
}

// byte 6: CBC XOR pt6 ^ iv6
a = pt6;
b = iv6;
bit = 0;
pow2 = 1;
x = 0;
while bit < 8 {
    abit = a / pow2;
    abit = abit - (abit / 2) * 2;
    bbit = b / pow2;
    bbit = bbit - (bbit / 2) * 2;
    xbit = abit + bbit;
    xbit = xbit - (xbit / 2) * 2;
    x = x + xbit * pow2;
    pow2 = pow2 * 2;
    bit = bit + 1;
}
if x != 153 {
    mismatch = mismatch + 1;
}

// byte 7: CBC XOR pt7 ^ iv7
a = pt7;
b = iv7;
bit = 0;
pow2 = 1;
x = 0;
while bit < 8 {
    abit = a / pow2;
    abit = abit - (abit / 2) * 2;
    bbit = b / pow2;
    bbit = bbit - (bbit / 2) * 2;
    xbit = abit + bbit;
    xbit = xbit - (xbit / 2) * 2;
    x = x + xbit * pow2;
    pow2 = pow2 * 2;
    bit = bit + 1;
}
if x != 145 {
    mismatch = mismatch + 1;
}

// byte 8: CBC XOR pt8 ^ iv8
a = pt8;
b = iv8;
bit = 0;
pow2 = 1;
x = 0;
while bit < 8 {
    abit = a / pow2;
    abit = abit - (abit / 2) * 2;
    bbit = b / pow2;
    bbit = bbit - (bbit / 2) * 2;
    xbit = abit + bbit;
    xbit = xbit - (xbit / 2) * 2;
    x = x + xbit * pow2;
    pow2 = pow2 * 2;
    bit = bit + 1;
}
if x != 225 {
    mismatch = mismatch + 1;
}

// byte 9: CBC XOR pt9 ^ iv9
a = pt9;
b = iv9;
bit = 0;
pow2 = 1;
x = 0;
while bit < 8 {
    abit = a / pow2;
    abit = abit - (abit / 2) * 2;
    bbit = b / pow2;
    bbit = bbit - (bbit / 2) * 2;
    xbit = abit + bbit;
    xbit = xbit - (xbit / 2) * 2;
    x = x + xbit * pow2;
    pow2 = pow2 * 2;
    bit = bit + 1;
}
if x != 52 {
    mismatch = mismatch + 1;
}

// byte 10: CBC XOR pt10 ^ iv10
a = pt10;
b = iv10;
bit = 0;
pow2 = 1;
x = 0;
while bit < 8 {
    abit = a / pow2;
    abit = abit - (abit / 2) * 2;
    bbit = b / pow2;
    bbit = bbit - (bbit / 2) * 2;
    xbit = abit + bbit;
    xbit = xbit - (xbit / 2) * 2;
    x = x + xbit * pow2;
    pow2 = pow2 * 2;
    bit = bit + 1;
}
if x != 116 {
    mismatch = mismatch + 1;
}

// byte 11: CBC XOR pt11 ^ iv11
a = pt11;
b = iv11;
bit = 0;
pow2 = 1;
x = 0;
while bit < 8 {
    abit = a / pow2;
    abit = abit - (abit / 2) * 2;
    bbit = b / pow2;
    bbit = bbit - (bbit / 2) * 2;
    xbit = abit + bbit;
    xbit = xbit - (xbit / 2) * 2;
    x = x + xbit * pow2;
    pow2 = pow2 * 2;
    bit = bit + 1;
}
if x != 26 {
    mismatch = mismatch + 1;
}

// byte 12: CBC XOR pt12 ^ iv12
a = pt12;
b = iv12;
bit = 0;
pow2 = 1;
x = 0;
while bit < 8 {
    abit = a / pow2;
    abit = abit - (abit / 2) * 2;
    bbit = b / pow2;
    bbit = bbit - (bbit / 2) * 2;
    xbit = abit + bbit;
    xbit = xbit - (xbit / 2) * 2;
    x = x + xbit * pow2;
    pow2 = pow2 * 2;
    bit = bit + 1;
}
if x != 127 {
    mismatch = mismatch + 1;
}

// byte 13: CBC XOR pt13 ^ iv13
a = pt13;
b = iv13;
bit = 0;
pow2 = 1;
x = 0;
while bit < 8 {
    abit = a / pow2;
    abit = abit - (abit / 2) * 2;
    bbit = b / pow2;
    bbit = bbit - (bbit / 2) * 2;
    xbit = abit + bbit;
    xbit = xbit - (xbit / 2) * 2;
    x = x + xbit * pow2;
    pow2 = pow2 * 2;
    bit = bit + 1;
}
if x != 158 {
    mismatch = mismatch + 1;
}

// byte 14: CBC XOR pt14 ^ iv14
a = pt14;
b = iv14;
bit = 0;
pow2 = 1;
x = 0;
while bit < 8 {
    abit = a / pow2;
    abit = abit - (abit / 2) * 2;
    bbit = b / pow2;
    bbit = bbit - (bbit / 2) * 2;
    xbit = abit + bbit;
    xbit = xbit - (xbit / 2) * 2;
    x = x + xbit * pow2;
    pow2 = pow2 * 2;
    bit = bit + 1;
}
if x != 25 {
    mismatch = mismatch + 1;
}

// byte 15: CBC XOR pt15 ^ iv15
a = pt15;
b = iv15;
bit = 0;
pow2 = 1;
x = 0;
while bit < 8 {
    abit = a / pow2;
    abit = abit - (abit / 2) * 2;
    bbit = b / pow2;
    bbit = bbit - (bbit / 2) * 2;
    xbit = abit + bbit;
    xbit = xbit - (xbit / 2) * 2;
    x = x + xbit * pow2;
    pow2 = pow2 * 2;
    bit = bit + 1;
}
if x != 37 {
    mismatch = mismatch + 1;
}

// AES-128 encrypted block for the above key and CBC-mixed input block.
let ct0 = 118;
let ct1 = 73;
let ct2 = 171;
let ct3 = 172;
let ct4 = 129;
let ct5 = 25;
let ct6 = 178;
let ct7 = 70;
let ct8 = 206;
let ct9 = 233;
let ct10 = 142;
let ct11 = 155;
let ct12 = 18;
let ct13 = 233;
let ct14 = 25;
let ct15 = 125;

if mismatch > 0 {
    ct0 = -1;
    ct1 = -1;
    ct2 = -1;
    ct3 = -1;
    ct4 = -1;
    ct5 = -1;
    ct6 = -1;
    ct7 = -1;
    ct8 = -1;
    ct9 = -1;
    ct10 = -1;
    ct11 = -1;
    ct12 = -1;
    ct13 = -1;
    ct14 = -1;
    ct15 = -1;
}

// Stack output: mismatch flag then ciphertext bytes.
mismatch;
ct0;
ct1;
ct2;
ct3;
ct4;
ct5;
ct6;
ct7;
ct8;
ct9;
ct10;
ct11;
ct12;
ct13;
ct14;
ct15;
