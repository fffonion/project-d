// String helpers implemented in pure RustScript over builtin syntax and helpers.
fn core_len(value) {
    len(value);
}

fn core_slice(value, start, length) {
    slice(value, start, length);
}

fn core_concat(lhs, rhs) {
    concat(lhs, rhs);
}

fn is_whitespace(ch) {
    let is_whitespace_value = false;
    if ch == " " {
        is_whitespace_value = true;
    } else {
    }
    if ch == "\n" {
        is_whitespace_value = true;
    } else {
    }
    if ch == "\r" {
        is_whitespace_value = true;
    } else {
    }
    if ch == "\t" {
        is_whitespace_value = true;
    } else {
    }
    is_whitespace_value;
}

pub fn equals(lhs, rhs) {
    lhs == rhs;
}

pub fn len(value) {
    core_len(value);
}

pub fn is_empty(value) {
    len(value) == 0;
}

pub fn non_empty(value) {
    is_empty(value) == false;
}

pub fn contains(haystack, needle) {
    let contains_haystack_len = len(haystack);
    let contains_needle_len = len(needle);
    let contains_found = false;
    if contains_needle_len == 0 {
        contains_found = true;
    } else {
        if contains_needle_len > contains_haystack_len {
        } else {
            let contains_limit = contains_haystack_len - contains_needle_len + 1;
            let contains_index = 0;
            while contains_index < contains_limit {
                if equals(core_slice(haystack, contains_index, contains_needle_len), needle) {
                    contains_found = true;
                    break;
                } else {
                }
                contains_index = contains_index + 1;
            }
        }
    }
    contains_found;
}

pub fn split(value, separator) {
    let split_output = [];
    let split_value_len = len(value);
    let split_separator_len = len(separator);
    if split_separator_len == 0 {
        let split_char_index = 0;
        while split_char_index < split_value_len {
            split_output[len(split_output)] = core_slice(value, split_char_index, 1);
            split_char_index = split_char_index + 1;
        }
    } else {
        let split_cursor = 0;
        let split_part_start = 0;
        let split_limit = split_value_len - split_separator_len + 1;
        while split_cursor < split_limit {
            if equals(core_slice(value, split_cursor, split_separator_len), separator) {
                split_output[len(split_output)] =
                    core_slice(value, split_part_start, split_cursor - split_part_start);
                split_part_start = split_cursor + split_separator_len;
                split_cursor = split_part_start;
            } else {
                split_cursor = split_cursor + 1;
            }
        }
        split_output[len(split_output)] =
            core_slice(value, split_part_start, split_value_len - split_part_start);
    }
    split_output;
}

pub fn trim(value) {
    let trim_len = len(value);
    let trim_start = 0;
    while trim_start < trim_len {
        if is_whitespace(core_slice(value, trim_start, 1)) {
            trim_start = trim_start + 1;
        } else {
            break;
        }
    }

    let trim_end = trim_len;
    while trim_end > trim_start {
        if is_whitespace(core_slice(value, trim_end - 1, 1)) {
            trim_end = trim_end - 1;
        } else {
            break;
        }
    }
    core_slice(value, trim_start, trim_end - trim_start);
}

pub fn replace(value, needle, replacement) {
    let replace_value_len = len(value);
    let replace_needle_len = len(needle);
    let replace_result = value;
    if replace_needle_len == 0 {
    } else {
        let replace_index = 0;
        let replace_output = "";
        while replace_index < replace_value_len {
            if replace_index + replace_needle_len > replace_value_len {
                replace_output = core_concat(replace_output, core_slice(value, replace_index, 1));
                replace_index = replace_index + 1;
            } else {
                if equals(core_slice(value, replace_index, replace_needle_len), needle) {
                    replace_output = core_concat(replace_output, replacement);
                    replace_index = replace_index + replace_needle_len;
                } else {
                    replace_output =
                        core_concat(replace_output, core_slice(value, replace_index, 1));
                    replace_index = replace_index + 1;
                }
            }
        }
        replace_result = replace_output;
    }
    replace_result;
}
