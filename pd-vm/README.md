# Stack VM

This crate provides a compact stack-based VM intended as a compilation target for a higher-level language.

## Bytecode format

Bytecode is a stream of opcodes followed by little-endian operands. The VM uses absolute jump targets
and a separate constant table.

- 1 byte: opcode
- Operands: little-endian integers (u8, u16, u32)

### Constant table

Constants are stored in `Program.constants` and accessed by index via `ldc`.

### Instruction set

| Opcode | Mnemonic | Operands       | Stack effect                       |
|--------|----------|----------------|------------------------------------|
| 0x00   | `nop`    | -              | no change                          |
| 0x01   | `ret`    | -              | stop execution                     |
| 0x02   | `ldc`    | u32 index      | push constant                      |
| 0x03   | `add`    | -              | (a, b) -> (a + b)                  |
| 0x04   | `sub`    | -              | (a, b) -> (a - b)                  |
| 0x05   | `mul`    | -              | (a, b) -> (a * b)                  |
| 0x06   | `div`    | -              | (a, b) -> (a / b)                  |
| 0x07   | `neg`    | -              | (a) -> (-a)                        |
| 0x08   | `ceq`    | -              | (a, b) -> (a == b)                 |
| 0x09   | `clt`    | -              | (a, b) -> (a < b)                  |
| 0x0A   | `cgt`    | -              | (a, b) -> (a > b)                  |
| 0x0B   | `br`     | u32 target     | ip = target                        |
| 0x0C   | `brfalse`| u32 target     | pop bool; if false jump            |
| 0x0D   | `pop`    | -              | pop value                          |
| 0x0E   | `dup`    | -              | dup top of stack                   |
| 0x0F   | `ldloc`  | u8 index       | push local                         |
| 0x10   | `stloc`  | u8 index       | pop -> local                       |
| 0x11   | `call`   | u16 id, u8 argc| pop args, call host, push returns  |
| 0x12   | `shl`    | -              | (a, b) -> (a << b)                 |
| 0x13   | `shr`    | -              | (a, b) -> (a >> b)                 |

### Host calls and resuming

`call` invokes a host function registered in the VM. The host can return `Yield` to suspend execution.
Calling `vm.resume()` continues execution from the next instruction.

## Assembler and compiler skeleton

`Assembler` emits bytecode with labels and patches jumps when `finish_program()` is called.
`Compiler` is a small AST-to-bytecode skeleton that uses `Assembler` to generate control flow.
It now lowers `x * 2^n` to `shl` for cheaper integer math in generated bytecode.

### Text assembler

Use `assemble()` to parse a tiny assembly language into a `Program`.

Data section declarations:

- `const NAME VALUE`
- `string NAME "..."`

```
.data
const two 2
string greeting "hello"
.code
.local counter
.label loop
ldc two
stloc counter
ldloc counter
ldc 1
sub
dup
stloc counter
brfalse done
br loop
.label done
ldc greeting
ret
```

Directives:

- `.data` and `.code` switch sections
- `.label NAME` defines a label for jump targets
- `.local NAME [INDEX]` defines a named local

### Tiny compiler

Use `compile_source()` for Rust-like syntax (`.rss`) or `compile_source_file()` to auto-detect
syntax by extension (`.rss`, `.js`, `.lua`). It returns `CompiledProgram`, which includes the
program and required local count.

```
fn print(x);
let x = 2 + 3;
let y = x * 4;
if y > 10 {
	print(y);
} else {
	0;
}
```

Closure subset:

```
let base = 7;
let add = |value| value + base;
add(5);
```

Lua flavor closure syntax is lowered from:

```lua
local add = function(value) return value + base end
```

Built-in print aliases (no declaration needed):
- Rust-like: `print!(value);`
- JavaScript subset: `console.log(value);` and `print(value);`
- Lua subset: `print(value)`

Loop control supports `break` and `continue`.

JavaScript/Lua external declarations can use module forms (`import ...` / `require(...)`); calls
to unresolved names are treated as host externs in those flavors.

## Trace JIT (x86_64 first)

The VM now includes a trace-based JIT path inspired by LuaJIT's hot-loop tracing model:
- hot bytecode loop heads are detected
- a straight-line trace is recorded from that root
- x86_64 machine code is emitted per hot trace and invoked by the VM
- the native bridge executes trace semantics without bytecode re-decoding
- unsupported patterns fall back to interpreter and are tracked as NYI

Current NYI in trace compiler:
- `call` (host calls inside trace)
- `br` to non-root targets (only loop-back jump to trace root is supported)
- backward `brfalse` targets (only forward guard exits are supported)
- traces longer than configured max trace length
- non-`x86_64` targets (first implementation focus)

## Run examples

Use the VM runner binary:

```powershell
cargo run -p pd-vm --bin pd-vm-run -- examples/example.lua
```

Other flavors:

```powershell
cargo run -p pd-vm --bin pd-vm-run -- examples/example.js
cargo run -p pd-vm --bin pd-vm-run -- examples/example.rss
```

JIT visibility (dump compiled traces + NYI reasons):

```powershell
cargo run -p pd-vm --bin pd-vm-run -- --jit-hot-loop 2 --jit-dump examples/example.rss
```

Library API visibility hooks:
- `vm.set_jit_config(...)`
- `vm.jit_snapshot()`
- `vm.dump_jit_info()`
- `vm.jit_native_trace_count()`
- `vm.jit_native_exec_count()`

## Performance tests

Manual perf characterization tests (ignored by default):

```powershell
cargo test -p pd-vm --test perf_tests -- --ignored --nocapture
```

Includes:
- VM creation/cleanup speed and RSS delta
- compiler speed and RSS delta
- JIT native machine code execution verification on x86_64

### Debugger mode

Run with interactive `pdb` debugger on stdio:

```powershell
cargo run -p pd-vm --bin pd-vm-run -- --debug examples/example.lua
```

Run with TCP debugger socket:

```powershell
cargo run -p pd-vm --bin pd-vm-run -- --debug --tcp 127.0.0.1:9002 examples/example.lua
```

Useful `pdb` commands: `break`, `break line`, `step`, `next`, `out`, `stack`, `locals`, `where`, `continue`.

Try it with integration tests:

```powershell
cargo test -p pd-vm --test demo_migration_tests
```
